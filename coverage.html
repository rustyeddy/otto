
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>messanger: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rustyeddy/otto/messanger/messanger.go (95.8%)</option>
				
				<option value="file1">github.com/rustyeddy/otto/messanger/messanger_local.go (79.3%)</option>
				
				<option value="file2">github.com/rustyeddy/otto/messanger/messanger_mqtt.go (12.5%)</option>
				
				<option value="file3">github.com/rustyeddy/otto/messanger/messanger_nodes.go (100.0%)</option>
				
				<option value="file4">github.com/rustyeddy/otto/messanger/mqtt.go (72.6%)</option>
				
				<option value="file5">github.com/rustyeddy/otto/messanger/mqtt_mock.go (68.3%)</option>
				
				<option value="file6">github.com/rustyeddy/otto/messanger/msg.go (93.1%)</option>
				
				<option value="file7">github.com/rustyeddy/otto/messanger/topics.go (92.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package messanger

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "sync"
)

var (
        messanger Messanger
        once      sync.Once
)

// Subscriber is an interface that defines a struct needs to have the
// Callback(topic string, data []byte) function defined.
type MsgHandler func(msg *Msg)

type Messanger interface {
        ID() string
        Subscribe(topic string, handler MsgHandler) error
        SetTopic(topic string)
        Topic() string
        PubMsg(msg *Msg)
        PubData(data any)
        Error() error
        Close()
}

func NewMessanger(id string, topics ...string) Messanger <span class="cov8" title="1">{
        if messanger != nil </span><span class="cov8" title="1">{
                slog.Warn("Calling new messanger when one already exists",
                        "old", messanger.ID(), "new", id)
                messanger = nil
        }</span>

        <span class="cov8" title="1">switch id </span>{
        case "local":<span class="cov8" title="1">
                messanger = NewMessangerLocal(id, topics...)</span>
        case "mqtt":<span class="cov8" title="1">
                messanger = NewMessangerMQTT(id, topics...)</span>
        default:<span class="cov8" title="1">
                messanger = nil</span>
        }
        <span class="cov8" title="1">return messanger</span>
}

// GetMessangerInstance returns the singleton instance of MessangerBase.
// It ensures that only one instance of MessangerBase is created.
func GetMessanger() Messanger <span class="cov8" title="1">{
        return messanger
}</span>

// MessangerBase
type MessangerBase struct {
        id    string
        topic []string
        subs  map[string][]MsgHandler
        error

        Published int
}

func NewMessangerBase(id string, topic ...string) *MessangerBase <span class="cov8" title="1">{
        return &amp;MessangerBase{
                id:    id,
                topic: topic,
                subs:  make(map[string][]MsgHandler),
        }
}</span>

func (mb *MessangerBase) ID() string <span class="cov8" title="1">{
        return mb.id
}</span>

func (mb *MessangerBase) Topic() string <span class="cov8" title="1">{
        if len(mb.topic) &lt; 1 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return mb.topic[0]</span>
}

func (mb *MessangerBase) SetTopic(topic string) <span class="cov8" title="1">{
        mb.topic = append(mb.topic, topic)
}</span>

func (mb *MessangerBase) Error() error <span class="cov8" title="1">{
        return mb.error
}</span>

// ServeHTTP is the REST API entry point for the messanger package
func (m MessangerBase) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        var subs []string
        for s, _ := range m.subs </span><span class="cov8" title="1">{
                subs = append(subs, s)
        }</span>

        <span class="cov8" title="1">mbase := struct {
                ID        string
                Topics    []string
                Subs      []string
                Published int
        }{
                ID:        m.id,
                Subs:      subs,
                Topics:    m.topic,
                Published: m.Published,
        }

        w.Header().Set("Content-Type", "application/json")
        err := json.NewEncoder(w).Encode(mbase)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("MQTT.ServeHTTP failed to encode", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package messanger

import (
        "log/slog"
        "sync"
)

type MessangerLocal struct {
        *MessangerBase
        sync.Mutex `json:"-"`
}

// NewMessanger with the given ID and a variable number of topics that
// it will subscribe to.
func NewMessangerLocal(id string, topics ...string) *MessangerLocal <span class="cov8" title="1">{
        m := &amp;MessangerLocal{
                MessangerBase: NewMessangerBase(id, topics...),
        }
        return m
}</span>

// Subscribe will literally subscribe to the provide MQTT topic with
// the specified message handler.
func (m *MessangerLocal) Subscribe(topic string, handler MsgHandler) error <span class="cov8" title="1">{
        m.subs[topic] = append(m.subs[topic], handler)
        if root == nil </span><span class="cov0" title="0">{
                root = newNode("/")
        }</span>
        <span class="cov8" title="1">root.insert(topic, handler)
        return nil</span>
}

// Close is implemented to satisfy the messanger interface
func (m *MessangerLocal) Close() <span class="cov8" title="1">{
        // TODO - need to unsubscribe handlers for this messanger
        resetNodes()
        m.MessangerBase.subs = nil
}</span>

// Pub a message via MQTT with the given topic and value
func (m *MessangerLocal) Pub(topic string, value any) <span class="cov8" title="1">{
        m.Published++
        buf, err := Bytes(value)
        if err != nil </span><span class="cov0" title="0">{
                m.error = err
                return
        }</span>

        <span class="cov8" title="1">msg := NewMsg(topic, buf, m.id)
        m.PubMsg(msg)</span>
}

// PubMsg sends an MQTT message based on the content of the Msg structure
func (m *MessangerLocal) PubMsg(msg *Msg) <span class="cov8" title="1">{
        n := root.lookup(msg.Topic)
        if n == nil </span><span class="cov8" title="1">{
                slog.Info("No subscribers", "topic", msg.Topic)
                return
        }</span>
        <span class="cov8" title="1">n.pub(msg)</span>
}

// Publish given data to this messangers topic
func (m *MessangerLocal) PubData(data any) <span class="cov8" title="1">{
        if m.topic[0] == "" </span><span class="cov0" title="0">{
                slog.Error("Device.Publish failed has no Topic", "name", m.ID)
                return
        }</span>
        <span class="cov8" title="1">buf, err := Bytes(data)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">msg := NewMsg(m.topic[0], buf, m.id)
        m.PubMsg(msg)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package messanger

import (
        "fmt"
        "log/slog"
        "sync"
)

// Messanger represents a type that can publish and subscribe to messages
type MessangerMQTT struct {
        *MessangerBase
        *MQTT
        sync.Mutex `json:"-"`
}

// NewMessanger with the given ID and a variable number of topics that
// it will subscribe to.
func NewMessangerMQTT(id string, topics ...string) *MessangerMQTT <span class="cov8" title="1">{
        m := &amp;MessangerMQTT{
                MessangerBase: NewMessangerBase(id, topics...),
                MQTT:          NewMQTT(id, topics...),
        }
        return m
}</span>

func (m *MessangerMQTT) ID() string <span class="cov8" title="1">{
        return m.MessangerBase.ID()
}</span>

// Subscribe will literally subscribe to the provide MQTT topic with
// the specified message handler.
func (m *MessangerMQTT) Subscribe(topic string, handler MsgHandler) error <span class="cov0" title="0">{
        m.subs[topic] = append(m.subs[topic], handler)
        return m.MQTT.Subscribe(topic, handler)
}</span>

// Publish a message via MQTT with the given topic and value
func (m *MessangerMQTT) Pub(topic string, value any) <span class="cov0" title="0">{
        m.Published++
        m.Publish(topic, value)
}</span>

// PubMsg sends an MQTT message based on the content of the Msg structure
func (m *MessangerMQTT) PubMsg(msg *Msg) <span class="cov0" title="0">{
        m.Publish(msg.Topic, msg.Data)
}</span>

// Publish given data to this messangers topic
func (m *MessangerMQTT) PubData(data any) <span class="cov0" title="0">{
        if len(m.topic) &lt; 1 || m.topic[0] == "" </span><span class="cov0" title="0">{
                slog.Error("Device.Publish failed has no Topic", "name", m.MessangerBase.id)
                return
        }</span>
        <span class="cov0" title="0">var buf []byte

        switch data.(type) </span>{
        case []byte:<span class="cov0" title="0">
                buf = data.([]byte)</span>

        case string:<span class="cov0" title="0">
                buf = []byte(data.(string))</span>

        case int:<span class="cov0" title="0">
                str := fmt.Sprintf("%d", data.(int))
                buf = []byte(str)</span>

        case float64:<span class="cov0" title="0">
                str := fmt.Sprintf("%5.2f", data.(float64))
                buf = []byte(str)</span>

        default:<span class="cov0" title="0">
                slog.Error("Unknown Type: ", "topic", m.Topic, "type", fmt.Sprintf("%T", data))</span>
        }

        <span class="cov0" title="0">msg := NewMsg(m.topic[0], buf, m.MessangerBase.id)
        m.PubMsg(msg)</span>
}

func (m *MessangerMQTT) Error() error <span class="cov0" title="0">{
        return m.MQTT.Error()
}</span>

// MsgPrinter will simply print a Msg that has been supplied. TODO,
// create a member function that will print messages by msg ID.
type MsgPrinter struct{}

// MsgHandler will print out the message that has been supplied.
func (m *MsgPrinter) MsgHandler(msg *Msg) <span class="cov0" title="0">{
        fmt.Printf("%+v\n", msg)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package messanger

import "strings"

type node struct {
        index    string
        nodes    map[string]*node
        handlers []MsgHandler
}

var (
        root *node
)

func init() <span class="cov8" title="1">{
        root = &amp;node{
                nodes: make(map[string]*node),
        }
}</span>

func newNode(index string) *node <span class="cov8" title="1">{
        n := &amp;node{
                index: index,
                nodes: make(map[string]*node),
        }
        return n
}</span>

func initNodes() <span class="cov8" title="1">{
        root = &amp;node{
                nodes: make(map[string]*node),
        }
}</span>

func clearNodes() <span class="cov8" title="1">{
        root = nil
}</span>

func resetNodes() <span class="cov8" title="1">{
        clearNodes()
        initNodes()
}</span>

func (n *node) insert(topic string, mh MsgHandler) <span class="cov8" title="1">{
        indexes := strings.Split(topic, "/")
        pn := n
        for _, idx := range indexes </span><span class="cov8" title="1">{
                if nn, ex := pn.nodes[idx]; !ex </span><span class="cov8" title="1">{
                        nn = newNode(idx)
                        pn.nodes[idx] = nn
                        pn = nn
                }</span> else<span class="cov8" title="1"> {
                        pn = nn
                }</span>

        }
        // The last node push the callback on the callback list
        <span class="cov8" title="1">pn.handlers = append(pn.handlers, mh)</span>
}

func (n *node) lookup(topic string) *node <span class="cov8" title="1">{
        indexes := strings.Split(topic, "/")
        pn := n
        for _, idx := range indexes </span><span class="cov8" title="1">{

                nn, ex := pn.nodes[idx]
                if ex </span><span class="cov8" title="1">{
                        pn = nn
                        continue</span>
                }

                <span class="cov8" title="1">nn, ex = pn.nodes["#"]
                if ex </span><span class="cov8" title="1">{
                        return nn
                }</span>

                <span class="cov8" title="1">nn, ex = pn.nodes["+"]
                if ex </span><span class="cov8" title="1">{
                        // we will accept this path portion of the wildcard, but
                        // must continue on
                        pn = nn
                        continue</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return pn</span>
}

func (n *node) pub(m *Msg) <span class="cov8" title="1">{
        for _, h := range n.handlers </span><span class="cov8" title="1">{
                h(m)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package messanger

import (
        "fmt"
        "log"
        "log/slog"
        "os"

        gomqtt "github.com/eclipse/paho.mqtt.golang"
)

var (
        mqtt *MQTT
)

// MQTT is a wrapper around the Paho MQTT Go package
// Wraps the Broker, ID and Debug variables.
type MQTT struct {
        id     string `json:"id"`
        Broker string `json:"broker"`
        Debug  bool   `json:"debug"`

        error         `json:"error"`
        gomqtt.Client `json:"-"`
}

// NewMQTT creates a new instance of the MQTT client type.
func NewMQTT(id string, topics ...string) *MQTT <span class="cov8" title="1">{
        mqtt := &amp;MQTT{
                id:     id,
                Broker: "localhost",
        }
        return mqtt
}</span>

// SetMQTTClient allows a mock client to be used rather than an
// actual MQTT client to allow for Mocking MQTT connections if
// desired
func SetMQTTClient(c gomqtt.Client) *MQTT <span class="cov8" title="1">{
        if mqtt == nil </span><span class="cov8" title="1">{
                mqtt = &amp;MQTT{
                        id:     "default",
                        Broker: "localhost",
                }
        }</span>
        <span class="cov8" title="1">mqtt.Client = c
        return mqtt</span>
}

// GetMQTT returns the singleton instance of the MQTT client, the
// first time it is called it will initialize the client if needed.
func GetMQTT() *MQTT <span class="cov8" title="1">{
        if mqtt == nil </span><span class="cov8" title="1">{
                mqtt = &amp;MQTT{
                        id:     "default",
                        Broker: "localhost",
                }
        }</span>
        <span class="cov8" title="1">return mqtt</span>
}

func (m *MQTT) ID() string <span class="cov8" title="1">{
        return m.id
}</span>

// IsConnected will tell you if the MQTT client is connected to
// the specified broker
func (m *MQTT) IsConnected() bool <span class="cov8" title="1">{
        if m.Client == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return m.Client.IsConnected()</span>
}

func (m *MQTT) Error() error <span class="cov0" title="0">{
        return m.error
}</span>

// Connect to the MQTT broker after setting some MQTT options
// then connecting to the MQTT broker
func (m *MQTT) Connect() error <span class="cov8" title="1">{

        if m.Debug </span><span class="cov0" title="0">{
                gomqtt.DEBUG = log.Default()
                gomqtt.ERROR = log.Default()
        }</span>

        <span class="cov8" title="1">broker := os.Getenv("MQTT_BROKER")
        if broker != "" </span><span class="cov8" title="1">{
                m.Broker = broker
        }</span> else<span class="cov8" title="1"> {
                m.Broker = "localhost"
        }</span>
        <span class="cov8" title="1">url := "tcp://" + m.Broker + ":1883"
        opts := gomqtt.NewClientOptions()
        opts.AddBroker(url)
        opts.SetClientID(m.id)
        opts.SetCleanSession(true)

        // If we are testing m.Client will point to the mock client otherwise
        // in real life a new real client will be created
        if m.Client == nil </span><span class="cov0" title="0">{
                m.Client = gomqtt.NewClient(opts)
        }</span>

        <span class="cov8" title="1">token := m.Client.Connect()
        token.Wait()
        if token.Error() != nil </span><span class="cov8" title="1">{
                slog.Error("MQTT Connect: ", "error", token.Error())
                m.error = token.Error()
                return fmt.Errorf("Failed to connect to MQTT broker %s", token.Error())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Subscribe will cause messangers to the given topic to be passed along to the
// MsgHandle f
func (m *MQTT) Subscribe(topic string, f MsgHandler) error <span class="cov8" title="1">{
        if m.Client == nil </span><span class="cov0" title="0">{
                slog.Error("MQTT Client is not connected to a broker")
                return fmt.Errorf("MQTT Client is not connected to broker: %s", m.Broker)
        }</span>

        <span class="cov8" title="1">var err error
        token := m.Client.Subscribe(topic, byte(0), func(c gomqtt.Client, m gomqtt.Message) </span><span class="cov8" title="1">{
                slog.Debug("MQTT incoming: ", "topic", m.Topic(), "payload", string(m.Payload()))
                msg := NewMsg(m.Topic(), m.Payload(), "mqtt-sub")
                f(msg)
        }</span>)

        <span class="cov8" title="1">if token.Wait() &amp;&amp; token.Error() != nil </span><span class="cov0" title="0">{
                // TODO: add routing that automatically subscribes subscribers when a
                // connection has been made
                m.error = token.Error()
                return token.Error()
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Publish will publish a value to the given topic
func (m *MQTT) Publish(topic string, value any) <span class="cov8" title="1">{
        var t gomqtt.Token

        if topic == "" </span><span class="cov0" title="0">{
                panic("topic is nil")</span>
        }

        <span class="cov8" title="1">if m.Client == nil </span><span class="cov0" title="0">{
                slog.Warn("MQTT Client is not connected to a broker")
                return
        }</span>

        <span class="cov8" title="1">if t = m.Client.Publish(topic, byte(0), false, value); t == nil </span><span class="cov0" title="0">{
                if false </span><span class="cov0" title="0">{
                        slog.Info("MQTT Pub NULL token: ", "topic", topic, "value", value)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">t.Wait()
        if t.Error() != nil </span><span class="cov0" title="0">{
                m.error = t.Error()
                slog.Error("MQTT Publish token: ", "error", t.Error())
        }</span>
}

// Close will disconnect from the MQTT broker and close the client
// connection.
func (m *MQTT) Close() <span class="cov8" title="1">{
        m.Client.Disconnect(1000)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// mqtt_mock.go
// Mock implementation of the paho.mqtt.golang Client interface for testing.
// Provides comprehensive mocking of MQTT operations including connection,
// publishing, subscribing, and message handling.

package messanger

import (
        "errors"
        "sync"
        "time"

        gomqtt "github.com/eclipse/paho.mqtt.golang"
)

// MockToken implements gomqtt.Token interface
type MockToken struct {
        err    error
        waited bool
        mu     sync.Mutex
}

func NewMockToken(err error) *MockToken <span class="cov8" title="1">{
        return &amp;MockToken{err: err}
}</span>

func (t *MockToken) Wait() bool <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.waited = true
        return t.err == nil
}</span>

func (t *MockToken) WaitTimeout(timeout time.Duration) bool <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.waited = true
        return t.err == nil
}</span>

func (t *MockToken) Error() error <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return t.err
}</span>

func (t *MockToken) Done() &lt;-chan struct{} <span class="cov8" title="1">{
        done := make(chan struct{})
        close(done)
        return done
}</span>

// MockMessage implements gomqtt.Message interface
type MockMessage struct {
        topic     string
        payload   []byte
        qos       byte
        retained  bool
        duplicate bool
        messageID uint16
        acked     bool
}

func NewMockMessage(topic string, payload []byte) *MockMessage <span class="cov8" title="1">{
        return &amp;MockMessage{
                topic:   topic,
                payload: payload,
                qos:     0,
        }
}</span>

func (m *MockMessage) Duplicate() bool   <span class="cov8" title="1">{ return m.duplicate }</span>
func (m *MockMessage) Qos() byte         <span class="cov8" title="1">{ return m.qos }</span>
func (m *MockMessage) Retained() bool    <span class="cov8" title="1">{ return m.retained }</span>
func (m *MockMessage) Topic() string     <span class="cov8" title="1">{ return m.topic }</span>
func (m *MockMessage) MessageID() uint16 <span class="cov0" title="0">{ return m.messageID }</span>
func (m *MockMessage) Payload() []byte   <span class="cov8" title="1">{ return m.payload }</span>
func (m *MockMessage) Ack()              <span class="cov8" title="1">{ m.acked = true }</span>

// MockClientOptionsReader is a simple stub for ClientOptionsReader
type MockClientOptionsReader struct {
        clientID string
}

func (m *MockClientOptionsReader) ClientID() string <span class="cov0" title="0">{ return m.clientID }</span>

// Publication represents a published message for testing
type Publication struct {
        Topic    string
        Payload  interface{}
        QoS      byte
        Retained bool
}

// Subscription represents a subscription for testing
type Subscription struct {
        Topic   string
        QoS     byte
        Handler gomqtt.MessageHandler
}

// MockClient implements gomqtt.Client interface
// Provides comprehensive mocking capabilities for MQTT operations
type MockClient struct {
        mu         sync.RWMutex
        connected  bool
        connecting bool
        options    *MockClientOptionsReader

        // Error simulation
        connectErr     error
        publishErr     error
        subscribeErr   error
        unsubscribeErr error

        // Call tracking
        publications  []Publication
        subscriptions map[string]Subscription
        routes        map[string]gomqtt.MessageHandler

        // Connection tracking
        disconnectCalled  bool
        disconnectQuiesce uint

        // Callbacks
        onConnectHandler      gomqtt.OnConnectHandler
        connectionLostHandler gomqtt.ConnectionLostHandler
}

// NewMockClient creates a new mock MQTT client
func NewMockClient() *MockClient <span class="cov8" title="1">{
        return &amp;MockClient{
                options:       &amp;MockClientOptionsReader{},
                subscriptions: make(map[string]Subscription),
                routes:        make(map[string]gomqtt.MessageHandler),
        }
}</span>

// Connection methods
func (m *MockClient) IsConnected() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.connected
}</span>

func (m *MockClient) IsConnectionOpen() bool <span class="cov0" title="0">{
        return m.IsConnected()
}</span>

func (m *MockClient) Connect() gomqtt.Token <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.connectErr != nil </span><span class="cov8" title="1">{
                return NewMockToken(m.connectErr)
        }</span>

        <span class="cov8" title="1">m.connected = true
        m.connecting = false

        // Trigger connect callback if set
        if m.onConnectHandler != nil </span><span class="cov0" title="0">{
                go m.onConnectHandler(m)
        }</span>

        <span class="cov8" title="1">return NewMockToken(nil)</span>
}

func (m *MockClient) Disconnect(quiesce uint) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.connected = false
        m.disconnectCalled = true
        m.disconnectQuiesce = quiesce
}</span>

// Publishing methods
func (m *MockClient) Publish(topic string, qos byte, retained bool, payload interface{}) gomqtt.Token <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        pub := Publication{
                Topic:    topic,
                Payload:  payload,
                QoS:      qos,
                Retained: retained,
        }
        m.publications = append(m.publications, pub)

        return NewMockToken(m.publishErr)
}</span>

// Subscription methods
func (m *MockClient) Subscribe(topic string, qos byte, callback gomqtt.MessageHandler) gomqtt.Token <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.subscribeErr != nil </span><span class="cov8" title="1">{
                return NewMockToken(m.subscribeErr)
        }</span>

        <span class="cov8" title="1">sub := Subscription{
                Topic:   topic,
                QoS:     qos,
                Handler: callback,
        }
        m.subscriptions[topic] = sub

        return NewMockToken(nil)</span>
}

func (m *MockClient) SubscribeMultiple(filters map[string]byte, callback gomqtt.MessageHandler) gomqtt.Token <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.subscribeErr != nil </span><span class="cov0" title="0">{
                return NewMockToken(m.subscribeErr)
        }</span>

        <span class="cov0" title="0">for topic, qos := range filters </span><span class="cov0" title="0">{
                sub := Subscription{
                        Topic:   topic,
                        QoS:     qos,
                        Handler: callback,
                }
                m.subscriptions[topic] = sub
        }</span>

        <span class="cov0" title="0">return NewMockToken(nil)</span>
}

func (m *MockClient) Unsubscribe(topics ...string) gomqtt.Token <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        for _, topic := range topics </span><span class="cov8" title="1">{
                delete(m.subscriptions, topic)
        }</span>

        <span class="cov8" title="1">return NewMockToken(m.unsubscribeErr)</span>
}

// Routing methods
func (m *MockClient) AddRoute(topic string, callback gomqtt.MessageHandler) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.routes[topic] = callback
}</span>

func (m *MockClient) RemoveRoute(topic string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.routes, topic)
}</span>

// Configuration methods
func (m *MockClient) OptionsReader() gomqtt.ClientOptionsReader <span class="cov0" title="0">{
        // For testing purposes, we'll panic if this is called
        // Most MQTT testing doesn't require options reader functionality
        panic("OptionsReader not implemented in mock - modify test if needed")</span>
}

func (m *MockClient) SetOrderMatters(matter bool) {<span class="cov0" title="0">
        // No-op for mock
}</span>

// --- Mock Control Methods ---

// SetConnectError configures the mock to return an error on Connect()
func (m *MockClient) SetConnectError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connectErr = err
}</span>

// SetPublishError configures the mock to return an error on Publish()
func (m *MockClient) SetPublishError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.publishErr = err
}</span>

// SetSubscribeError configures the mock to return an error on Subscribe()
func (m *MockClient) SetSubscribeError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.subscribeErr = err
}</span>

// GetPublications returns all publications made through this mock client
func (m *MockClient) GetPublications() []Publication <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        pubs := make([]Publication, len(m.publications))
        copy(pubs, m.publications)
        return pubs
}</span>

// GetSubscriptions returns all active subscriptions
func (m *MockClient) GetSubscriptions() map[string]Subscription <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        subs := make(map[string]Subscription)
        for k, v := range m.subscriptions </span><span class="cov0" title="0">{
                subs[k] = v
        }</span>
        <span class="cov0" title="0">return subs</span>
}

// ClearPublications clears the publication history
func (m *MockClient) ClearPublications() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.publications = nil
}</span>

// SimulateMessage triggers a message delivery to subscribed handlers
// This allows testing of message handling logic
func (m *MockClient) SimulateMessage(topic string, payload []byte) error <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Check subscriptions first
        if sub, ok := m.subscriptions[topic]; ok </span><span class="cov8" title="1">{
                msg := NewMockMessage(topic, payload)
                if sub.Handler != nil </span><span class="cov8" title="1">{
                        go sub.Handler(m, msg)
                        return nil
                }</span>
        }

        // Check routes
        <span class="cov0" title="0">if handler, ok := m.routes[topic]; ok </span><span class="cov0" title="0">{
                msg := NewMockMessage(topic, payload)
                if handler != nil </span><span class="cov0" title="0">{
                        go handler(m, msg)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return errors.New("no handler found for topic: " + topic)</span>
}

// SimulateConnectionLost simulates a connection loss
func (m *MockClient) SimulateConnectionLost(err error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.connected = false
        handler := m.connectionLostHandler
        m.mu.Unlock()

        if handler != nil </span><span class="cov0" title="0">{
                go handler(m, err)
        }</span>
}

// IsDisconnectCalled returns true if Disconnect was called
func (m *MockClient) IsDisconnectCalled() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.disconnectCalled
}</span>

// GetLastPublication returns the most recent publication
func (m *MockClient) GetLastPublication() *Publication <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if len(m.publications) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;m.publications[len(m.publications)-1]</span>
}

// HasSubscription checks if a topic is subscribed
func (m *MockClient) HasSubscription(topic string) bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        _, exists := m.subscriptions[topic]
        return exists
}</span>

// Reset clears all mock state
func (m *MockClient) Reset() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.connected = false
        m.connecting = false
        m.disconnectCalled = false
        m.disconnectQuiesce = 0
        m.connectErr = nil
        m.publishErr = nil
        m.subscribeErr = nil
        m.unsubscribeErr = nil
        m.publications = nil
        m.subscriptions = make(map[string]Subscription)
        m.routes = make(map[string]gomqtt.MessageHandler)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package messanger

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/rustyeddy/otto/utils"
)

// Msg holds a value and some type of meta data to be pass around in
// the system. The Msg struct contains all the info need to communicate
// internally or over the PubSub protocol.  Every Msg has a unique ID
// that can optionally be tracked, saved or replayed for debugging or
// testing purposes.
type Msg struct {
        ID     int64    `json:"id"`
        Topic  string   `json:"topic"`
        Path   []string `json:"path"`
        Args   []string `json:"args"`
        Data   []byte   `json:"msg"`
        Source string   `json:"source"`

        Timestamp time.Duration `json:"timestamp"`
}

var (
        msgid    int64 = 0
        msgSaver *MsgSaver
)

// getMsgID returns a globally unique message ID. It simply increments
// the ID by 1 every time it is called. This ID will uniquely identify
// exact elements used by the system.
func getMsgID() int64 <span class="cov8" title="1">{
        msgid++
        return msgid
}</span>

func Bytes(data any) ([]byte, error) <span class="cov8" title="1">{
        var buf []byte

        switch data.(type) </span>{
        case []byte:<span class="cov8" title="1">
                buf = data.([]byte)</span>

        case string:<span class="cov8" title="1">
                buf = []byte(data.(string))</span>

        case int:<span class="cov8" title="1">
                str := fmt.Sprintf("%d", data.(int))
                buf = []byte(str)</span>

        case bool:<span class="cov8" title="1">
                str := "false"
                if data.(bool) </span><span class="cov8" title="1">{
                        str = "true"
                }</span>
                <span class="cov8" title="1">buf = []byte(str)</span>

        case float64:<span class="cov8" title="1">
                str := fmt.Sprintf("%5.2f", data.(float64))
                buf = []byte(str)</span>

        default:<span class="cov8" title="1">
                err := errors.New("Can not convert data type " + fmt.Sprintf("%T", data))
                return nil, err</span>
        }
        <span class="cov8" title="1">return buf, nil</span>
}

// New creates a new Msg from the given topic, data and a source
// string.
func NewMsg(topic string, data []byte, source string) *Msg <span class="cov8" title="1">{
        msg := &amp;Msg{
                ID:        getMsgID(),
                Topic:     topic,
                Path:      strings.Split(topic, "/"),
                Data:      data,
                Timestamp: utils.Timestamp(),
                Source:    source,
        }

        if msgSaver != nil &amp;&amp; msgSaver.Saving </span><span class="cov0" title="0">{
                msgSaver.Messages = append(msgSaver.Messages, msg)
        }</span>
        <span class="cov8" title="1">return msg</span>
}

// Station extracts the station element from the Msg topic and returns
// the station ID/name to the caller.
func (msg *Msg) Station() string <span class="cov8" title="1">{
        if len(msg.Path) &lt; 3 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return msg.Path[2]</span>
}

// Last returns the Last element in the Msg.Topic path
func (msg *Msg) Last() string <span class="cov8" title="1">{
        l := len(msg.Path)
        if l == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return msg.Path[l-1]</span>
}

// Byte returns the array version of the Msg.Data
func (msg *Msg) Byte() []byte <span class="cov8" title="1">{
        return msg.Data
}</span>

// String returns the string formatted version of Msg.Data
func (msg *Msg) String() string <span class="cov8" title="1">{
        return string(msg.Data)
}</span>

// Float64 returns the float64 version of the Msg.Data
func (msg *Msg) Float64() float64 <span class="cov8" title="1">{
        var f float64
        fmt.Sscanf(msg.String(), "%f", &amp;f)
        return f
}</span>

// IsJSON returns true or false to indicate if the Msg.Data payload is
// a JSON formatted string/byte array or not.
func (msg *Msg) IsJSON() bool <span class="cov8" title="1">{
        return json.Valid(msg.Data)
}</span>

// JSON encodes the Msg.Data into a JSON formatted byte array.
func (msg *Msg) JSON() ([]byte, error) <span class="cov8" title="1">{
        jbytes, err := json.Marshal(msg)
        return jbytes, err
}</span>

// Map decodes the Msg.Data payload from a JSON formatted byte array
// into a map where the key/value pairs are the data index and values.
func (msg *Msg) Map() (map[string]interface{}, error) <span class="cov8" title="1">{
        var m map[string]interface{}
        err := json.Unmarshal(msg.Data, &amp;m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Failed to unmarshal data: %s", err)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// Dump spits out the fields and values of the Msg data struct
func (msg *Msg) Dump() string <span class="cov8" title="1">{
        str := fmt.Sprintf("  ID: %d\n", msg.ID)
        str += fmt.Sprintf("Path: %q\n", msg.Path)
        str += fmt.Sprintf("Args: %q\n", msg.Args)
        str += fmt.Sprintf(" Src: %s\n", msg.Source)
        str += fmt.Sprintf("Time: %s\n", msg.Timestamp)
        str += fmt.Sprintf("Data: %s\n", string(msg.Data))

        return str
}</span>

// MsgSaver struct is used to store a historical record of message
// captured by the application. Save the messages can be turned on and
// off at any given time.  TODO: need to be able to save these
// messages to a file, or deliver them via a protocol.
type MsgSaver struct {
        Messages []*Msg `json:"saved-messages"`
        Saving   bool   `json:"saving"`
}

// GetMsgSaver will return the instance of the MsgSaver element. The
// first time this funcction is called the object will be created.
func GetMsgSaver() *MsgSaver <span class="cov8" title="1">{
        if msgSaver == nil </span><span class="cov8" title="1">{
                msgSaver = &amp;MsgSaver{}
        }</span>
        <span class="cov8" title="1">return msgSaver</span>
}

// StartSaving turn on message saving
func (ms *MsgSaver) StartSaving() <span class="cov8" title="1">{
        ms.Saving = true
}</span>

// StopSaving disable message saving
func (ms *MsgSaver) StopSaving() <span class="cov8" title="1">{
        ms.Saving = false
}</span>

// Dump spits out the history of messages
func (ms *MsgSaver) Dump() <span class="cov0" title="0">{
        for _, msg := range ms.Messages </span><span class="cov0" title="0">{
                println(msg.Dump())
                println("----------------------------------------------")
        }</span>
}

// ServeHTTP will respond to the writer with 'Pong'
func (ms *MsgSaver) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(ms)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package messanger

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
)

// Topics maintains the list of topics used by otto and the
// applications. It maintains the topic format and a count for each
// time the topic is used
type Topics struct {
        StationName string
        TopicFmt    string
        Topicmap    map[string]int
}

var (
        topics *Topics
)

func init() <span class="cov8" title="1">{
        topics = &amp;Topics{
                TopicFmt:    "ss/%s/%s/%s",
                Topicmap:    make(map[string]int),
                StationName: "",
        }
}</span>

// GetTopics will return the Topics structure, one per application.
func GetTopics() *Topics <span class="cov8" title="1">{
        return topics
}</span>

// SetStationName will use the value to set the station that will be
// used when publishing messages from this station.
func (t *Topics) SetStationName(name string) <span class="cov8" title="1">{
        t.StationName = name
}</span>

// Control will return a control topic e.g. ss/c/station/foo
func (t *Topics) Control(topic string) string <span class="cov8" title="1">{
        top := fmt.Sprintf(t.TopicFmt, "c", t.StationName, topic)
        t.Topicmap[top]++
        return top
}</span>

// Control will return a data topic e.g. ss/d/station/foo
func (t *Topics) Data(topic string) string <span class="cov8" title="1">{
        top := fmt.Sprintf(t.TopicFmt, "d", t.StationName, topic)
        t.Topicmap[top]++
        return top
}</span>

// ServeHTTP is a JSON endpoint that returns all the topics used by
// this station.
func (t Topics) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        w.Header().Set("Content-Type", "application/json")
        err := json.NewEncoder(w).Encode(t)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Error wrote data", "error", err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
